---
title: "Concepts of Bayesian Data Analysis: Project4"
author:
  - Charles Muiruri^[Hasselt University, charles.muiruri@student.uhasselt.be]
  - Gianni Guarraci^[Hasselt University, gianni.guarraci@student.uhasselt.be]
  - Juan Vanegas Jadan^[Hasselt University, juan.vanegasjadan@student.uhasselt.be]
  - Ronald Makanga^[Hasselt University, ronald.makanga@student.uhasselt.be]
date: Report generated - `r format(Sys.time(), "%B %d, %Y")`
output: 
  pdf_document: 
    toc: true
---


```{r setup, include=FALSE}
knitr::opts_chunk$set(
  echo = FALSE,
  message = FALSE,
  warning = FALSE,
  fig.height = 12,
  fig.width = 12
  )
```


```{r load_packages, include=FALSE}

if (!require(pacman)) install.packages("pacman")
p_load(rjags, coda, nimble, R2OpenBUGS, ggplot2, here, dplyr, ggpubr, tidyr)

```


```{r load_data, include=FALSE}
projdata <- as.data.frame(read.csv(here("data/projectdata.txt")))|>
  mutate(less_133pc = ifelse(Poverty == "<133% FPL", 1,0),
         btn133_400_pc = ifelse(Poverty == "133% to <400% FPL", 1,0),
         great_400pc = ifelse(Poverty == ">400% FPL", 1,0))
```


```{r prepDta, include=FALSE}
# Data prep for bugs
model_data <- list(
  Y = projdata$Vaccinated,
  N = projdata$Sample.Size,
  btn133_400_pc = projdata$btn133_400_pc,
  great_400pc = projdata$great_400pc,
  J = nrow(projdata)
)
```


```{r initial_values, include=FALSE}
model_inits <- list(
  list(beta0 = 0, beta1 = 0, beta2 = 0)
)

parameters <- c("beta0", "beta1", "beta2")
```


```{r define_model, include=FALSE}
model1 <- function(){
  for (i in 1:J){
    Y[i] ~ dbin(p[i], N[i])
    logit(p[i]) <- beta0 + beta1*btn133_400_pc[i] + beta2*great_400pc[i]
  }
  #priors
  beta0 ~ dnorm(0, 0.001)
  beta1 ~ dnorm(0, 0.001)
  beta2 ~ dnorm(0, 0.001)
}

# Write model to file
write.model(model1, here("models/model1code.txt"))
# View file
# file.show(here("models/model1code.txt"))
```

\newpage 
# Modeling using Open Bugs

## Model

```{r model}
model.out <- bugs(model_data, model_inits, 
                  parameters = parameters, model.file = here("models/model1code.txt"),
                  n.chains = 1, n.iter = 10000, n.burnin = 5000, codaPkg = TRUE, debug = FALSE)

# debug=TRUE opens openBug and displays traceplots and summaries

out <- read.bugs(model.out)
summary(out)
HPDinterval(out, prob = 0.95)
```
## Question 1:
```{r Q1}
inverse_logit <- function(x) {
  1 / (1 + exp(-x))
}
out.summary <- summary(out)
beta0_mean <- out.summary[[1]]["beta0","Mean"]
beta1_mean <- out.summary[[1]]["beta1","Mean"]
beta2_mean <- out.summary[[1]]["beta2","Mean"]
pi_133 <- inverse_logit(beta0_mean)
pi_133_400 <- inverse_logit(beta1_mean + beta0_mean)
pi_400 <- inverse_logit(beta2_mean + beta0_mean)

cat("The mean probability of vaccination coverage for each poverty group is as follows:\n")
cat("<133% FPL: ", pi_133, "\n")
cat("133% to <400% FPL: ", pi_133_400, "\n")
cat(">400% FPL: ", pi_400, "\n")
```

## Density plots

```{r density_plots}
# Prep data for density and trace plots
mcmc_samples <- as.mcmc(out)
mcmc_df <- as.data.frame(mcmc_samples)
mcmc_df$iteration <- 1:nrow(mcmc_df)
mcmc_long <- pivot_longer(mcmc_df, cols = -iteration, names_to = "Parameter", values_to = "Value")

hpd <- HPDinterval(out, prob = 0.95)
hpd[[1]]["beta1", "lower"]

points_data <- data.frame(x = inverse_logit(mcmc_df$beta0), x1 = inverse_logit(mcmc_df$beta1),x2 = inverse_logit(mcmc_df$beta2),
                          x3 = mcmc_df$deviance,y = rep(0, nrow(mcmc_df)))

ggarrange(p_beta0 <- ggplot(mcmc_df, aes(x = beta0)) +
  geom_density(fill = "blue", alpha = 0.1) +
  geom_point(data = points_data, aes(x = x, y = y)) +
  labs(title = "Posterior Distribution of beta0", x = "beta0", y = "Density")+
  geom_vline(aes(xintercept = hpd[[1]]["beta0", "lower"]), linetype = "dashed", color = "red") +
  geom_vline(aes(xintercept = hpd[[1]]["beta0", "upper"]), linetype = "dashed", color = "red") +
  theme_bw(base_size = 12)+
  theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank()),

p_beta1 <- ggplot(mcmc_df, aes(x = beta1)) +
  geom_density(fill = "green", alpha = 0.1) +
  geom_point(data = points_data, aes(x = x1, y = y)) +
  labs(title = "Posterior Distribution of beta1", x = "beta1", y = "Density") +
  geom_vline(aes(xintercept = hpd[[1]]["beta1", "lower"]), linetype = "dashed", color = "red") +
  geom_vline(aes(xintercept = hpd[[1]]["beta1", "upper"]), linetype = "dashed", color = "red") +
  theme_bw(base_size = 12)+
  theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank()),

p_beta2 <- ggplot(mcmc_df, aes(x = beta2)) +
  geom_density(fill = "red", alpha = 0.1) +
  geom_point(data = points_data, aes(x = x2, y = y)) +
  labs(title = "Posterior Distribution of beta2", x = "beta2", y = "Density")+
  geom_vline(aes(xintercept = hpd[[1]]["beta2", "lower"]), linetype = "dashed", color = "red") +
  geom_vline(aes(xintercept = hpd[[1]]["beta2", "upper"]), linetype = "dashed", color = "red") +
  theme_bw(base_size = 12)+
  theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank()),

p_dev <- ggplot(mcmc_df, aes(x = deviance)) +
  geom_density(fill = "yellow", alpha = 0.1) +
  geom_point(data = points_data, aes(x = x3, y = y)) +
  labs(title = "Posterior Distribution of deviance", x = "Deviance", y = "Density")+
  geom_vline(aes(xintercept = hpd[[1]]["deviance", "lower"]), linetype = "dashed", color = "red") +
  geom_vline(aes(xintercept = hpd[[1]]["deviance", "upper"]), linetype = "dashed", color = "red") +
  theme_bw(base_size = 12)+
  theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank()), nrow = 2, ncol = 2)
```

### Summary of posterior distribution

  - The Posterior of **$\beta_0$** has a mean of **`r summary(out)[[1]]["beta0","Mean"]`** which is the central tendency of the intercept term,  with a 95% credible HPD interval of **(`r hpd[[1]]["beta0", "lower"]`, `r hpd[[1]]["beta0", "upper"]`)** in which the intercept term lies with 95% probability.
  - The Posterior of **$\beta_1$** has a mean of **`r summary(out)[[1]]["beta1","Mean"]`** which is the central tendency of the Poverty = `133% to <400% FPL` term, with a 95% HPD interval of **(`r hpd[[1]]["beta1", "lower"]`, `r hpd[[1]]["beta1", "upper"]`)** in which this Poverty term lies with 95% probability.
  - The Posterior of **$\beta_2$** has a mean of **`r summary(out)[[1]]["beta2","Mean"]`** which is the central tendency of the Poverty = `>400% FPL` term, with a 95% HPD interval of **(`r hpd[[1]]["beta2", "lower"]`, `r hpd[[1]]["beta2", "upper"]`)** in which this Poverty term lies with 95% probability.
  - The Posterior of the **Deviance** has a mean of **`r summary(out)[[1]]["deviance","Mean"]`** which is the central tendency of the Deviance, with a 95% HPD interval of **(`r hpd[[1]]["deviance", "lower"]`, `r hpd[[1]]["deviance", "upper"]`)**.


## Trace Plots

```{r trace_plots}
ggplot(mcmc_long|>filter(iteration > 4800), aes(x = iteration, y = Value, color = Parameter)) +
  geom_line() +
  scale_color_manual(values = c("blue", "green", "red", "yellow")) +
  facet_wrap(~ Parameter, scales = "free_y") +
  labs(title = "Trace Plots of MCMC Samples", x = "Iteration", y = "Parameter Value") +
  theme_bw(base_size = 12)+
  theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank(), legend.position = "none")
```

## Correlation plot

```{r correlation_plot, fig.height=6, fig.width=7}
crosscorr.plot(out)

```

## Autocorrelation plot

```{r autocorrelation_plot, fig.height=6, fig.width=7}
autocorr.plot(out)
```
Intepretation of the results is done in the main text.

## Question 6
Investigate whether the vaccination coverages are distinct at the different locations by adding a location-specific intercept.

For this, beta0 is assumed to be the logit of the proportion of vaccinated individuals for each location in the group less than 133% FPL, so we need to calculate it. So we will find just the proportion for groups 

```{r Q6}
model1 <- function(){
  for (i in 1:J){
    Y[i] ~ dbin(p[i], N[i])
    logit(p[i]) <- beta0[i] + beta1*btn133_400_pc[i] + beta2*great_400pc[i]
  }
  beta1 ~ dnorm(0, 0.001)
  beta2 ~ dnorm(0, 0.001)
}

write.model(model1, here("models/model2code.txt"))
projdata.beta0 <- projdata %>%
  filter(less_133pc == 1) %>%
  group_by(Geography) %>%
  mutate(beta0 = logit(sum(Vaccinated)/sum(Sample.Size))) %>%
  select(Geography, beta0)

projdata <- left_join(projdata, projdata.beta0, by = "Geography")

model_data_loc <- list(
  Y = projdata$Vaccinated,
  N = projdata$Sample.Size,
  beta0 = projdata$beta0,
  btn133_400_pc = projdata$btn133_400_pc,
  great_400pc = projdata$great_400pc,
  J = nrow(projdata),
  Location = projdata$Location
)

model_inits_loc <- list( list(beta1 = 0, beta2 = 0) )
parameters_loc <- c("beta1", "beta2")
model.out <- bugs(model_data_loc, model_inits_loc, 
                  parameters = parameters_loc, model.file = here("models/model2code.txt"),
                  n.chains = 1, n.iter = 10000, n.burnin = 5000, codaPkg = TRUE, debug = FALSE)

out.loc <- read.bugs(model.out)
```
```{r Q6_summary}

out.summary <- summary(out.loc)
beta1_mean <- out.summary[[1]]["beta1","Mean"]
beta2_mean <- out.summary[[1]]["beta2","Mean"]
pi_133 <- mean(inverse_logit(projdata$beta0))
pi_133_400 <- inverse_logit(beta1_mean + beta0_mean)
pi_400 <- inverse_logit(beta2_mean + beta0_mean)

cat("The mean probability of vaccination coverage for each poverty group is as follows:\n")
cat("Giving a value to beta0 means that the proportion for the group less than 133% FPL is the logit of beta0 \n")
cat("<133% FPL: ", pi_133, "\n")
cat("133% to <400% FPL: ", pi_133_400, "\n")
cat(">400% FPL: ", pi_400, "\n")
```

\newpage

# Appendix
`R Code`
```{r eval=FALSE, echo=TRUE}

if (!require(pacman)) install.packages("pacman")
p_load(rjags, coda, nimble, R2OpenBUGS, ggplot2, here, dplyr, ggpubr, tidyr)

projdata <- as.data.frame(read.csv(here("data/projectdata.txt")))|>
  mutate(less_133pc = ifelse(Poverty == "<133% FPL", 1,0),
         btn133_400_pc = ifelse(Poverty == "133% to <400% FPL", 1,0),
         great_400pc = ifelse(Poverty == ">400% FPL", 1,0))
# Data prep for bugs
model_data <- list(
  Y = projdata$Vaccinated,
  N = projdata$Sample.Size,
  btn133_400_pc = projdata$btn133_400_pc,
  great_400pc = projdata$great_400pc,
  J = nrow(projdata)
)

model_inits <- list(
  list(beta0 = 0, beta1 = 0, beta2 = 0)
)

parameters <- c("beta0", "beta1", "beta2")

model1 <- function(){
  for (i in 1:J){
    Y[i] ~ dbin(p[i], N[i])
    logit(p[i]) <- beta0 + beta1*btn133_400_pc[i] + beta2*great_400pc[i]
  }
  #priors
  beta0 ~ dnorm(0, 0.001)
  beta1 ~ dnorm(0, 0.001)
  beta2 ~ dnorm(0, 0.001)
}

# Write model to file
write.model(model1, here("models/model1code.txt"))
# View file
file.show(here("models/model1code.txt"))

model.out <- bugs(model_data, model_inits, 
                  parameters = parameters, model.file = here("models/model1code.txt"),
                  n.chains = 1, n.iter = 10000, n.burnin = 5000, codaPkg = TRUE, 
                  debug = FALSE)

# debug=TRUE opens openBug and displays traceplots and summaries

# Model output
out <- read.bugs(model.out)
summary(out)

# Prep data for density and trace plots
mcmc_samples <- as.mcmc(out)
mcmc_df <- as.data.frame(mcmc_samples)
mcmc_df$iteration <- 1:nrow(mcmc_df)
mcmc_long <- pivot_longer(mcmc_df, cols = -iteration, names_to = "Parameter",
                          values_to = "Value")

points_data <- data.frame(x = mcmc_df$beta0, x1 = mcmc_df$beta1,x2 = mcmc_df$beta2,
                          x3 = mcmc_df$deviance,y = rep(0, nrow(mcmc_df)))

# Density plots
ggarrange(p_beta0 <- ggplot(mcmc_df, aes(x = beta0)) +
            geom_density(fill = "blue", alpha = 0.1) +
            geom_point(data = points_data, aes(x = x, y = y)) +
            labs(title = "Posterior Distribution of beta0", x = "beta0", y = "Density")+
            theme_bw(base_size = 12)+
            theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank()),
          
          p_beta1 <- ggplot(mcmc_df, aes(x = beta1)) +
            geom_density(fill = "green", alpha = 0.1) +
            geom_point(data = points_data, aes(x = x1, y = y)) +
            labs(title = "Posterior Distribution of beta1", x = "beta1", y = "Density") +
            theme_bw(base_size = 12)+
            theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank()),
          
          p_beta2 <- ggplot(mcmc_df, aes(x = beta2)) +
            geom_density(fill = "red", alpha = 0.1) +
            geom_point(data = points_data, aes(x = x2, y = y)) +
            labs(title = "Posterior Distribution of beta2", x = "beta2", y = "Density")+
            theme_bw(base_size = 12)+
            theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank()),
          
          p_dev <- ggplot(mcmc_df, aes(x = deviance)) +
            geom_density(fill = "yellow", alpha = 0.1) +
            geom_point(data = points_data, aes(x = x3, y = y)) +
            labs(title = "Posterior Distribution of deviance", x = "Deviance", y = "Density")+
            theme_bw(base_size = 12)+
            theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank()), 
          nrow = 2, ncol = 2)

# Trace plots
ggplot(mcmc_long, aes(x = iteration, y = Value, color = Parameter)) +
  geom_line() +
  scale_color_manual(values = c("blue", "green", "red", "yellow")) +
  facet_wrap(~ Parameter, scales = "free_y") +
  labs(title = "Trace Plots of MCMC Samples", x = "Iteration", y = "Parameter Value") +
  theme_bw(base_size = 12)+
  theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank(), 
        legend.position = "none")

# Autocorrelation and crosscorrelation plots
crosscorr.plot(out)
autocorr.plot(out)

```

\newpage

QUESTION 4: Calculate the posterior probability that the vaccination coverage target (90%) is reached for each poverty group.

```{r Q4_calc, fig.height=6, fig.width=7}
# Load necessary libraries
library(dplyr)
library(rjags)
library(coda)
library(ggplot2)
library(here)
library(tidyr)

# mcmc_samples contains the posterior samples
mcmc_samples <- as.mcmc(out)
posterior_samples <- as.data.frame(mcmc_samples)

# Function to calculate probability from log-odds
logit_to_prob <- function(logit) {
  exp(logit) / (1 + exp(logit))
}

# Calculate the probabilities for each poverty group
posterior_samples <- posterior_samples %>%
  mutate(
    pi_133less = logit_to_prob(beta0),
    pi_133_400 = logit_to_prob(beta0 + beta1),
    pi_400more = logit_to_prob(beta0 + beta2)
  )

# Calculate the proportion of samples where vaccination probability is >= 90%
target_coverage <- 0.90

prob_133less_reached <- mean(posterior_samples$pi_133less >= target_coverage)
prob_133_400_reached <- mean(posterior_samples$pi_133_400 >= target_coverage)
prob_400more_reached <- mean(posterior_samples$pi_400more >= target_coverage)

# Print the results
cat("Posterior probability that vaccination coverage target (90%) is reached:\n")
cat("<133% FPL: ", prob_133less_reached, "\n")
cat("133-400% FPL: ", prob_133_400_reached, "\n")
cat(">400% FPL: ", prob_400more_reached, "\n")

```

```{r, fig.height=6, fig.width=7}
# Combine the results into a data frame for plotting
posterior_probs_df <- data.frame(
  PovertyGroup = c("<133% FPL", "133-400% FPL", ">400% FPL"),
  Probability = c(prob_133, prob_133_400, prob_400)
)

# Print the probabilities
print(posterior_probs_df)
```

```{r, fig.height=6, fig.width=7}
# Plot the probabilities using ggplot2
ggplot(posterior_probs_df, aes(x = PovertyGroup, y = Probability)) +
  geom_bar(stat = "identity", fill = c("blue", "green", "red"), alpha = 0.7) +
  geom_text(aes(label = scales::percent(Probability, accuracy = 0.1)), vjust = -0.3, size = 5) +
  ylim(0, 1) +
  labs(
    title = "Posterior Probability of Reaching 90% Vaccination Coverage",
    x = "Poverty Group",
    y = "Probability"
  ) +
  theme_minimal(base_size = 15)

```

```{r Q4_plot, fig.height=6, fig.width=7}
# Assuming posterior_samples already contains the calculated probabilities
posterior_samples <- posterior_samples %>%
  mutate(
    pi_133less = logit_to_prob(beta0),
    pi_133_400 = logit_to_prob(beta0 + beta1),
    pi_400more = logit_to_prob(beta0 + beta2)
  )

# Function to create density plot with 90% threshold line
create_density_plot <- function(data, var, group_name) {
  ggplot(data, aes_string(x = var)) +
    geom_density(fill = "blue", alpha = 0.3) +
    geom_vline(xintercept = 0.9, linetype = "dashed", color = "red") +
    labs(title = paste("Posterior Distribution for", group_name),
         x = "Vaccination Probability",
         y = "Density") +
    theme_minimal() +
    theme(plot.title = element_text(hjust = 0.5))
}

# Create density plots for each group
p1 <- create_density_plot(posterior_samples, "pi_133less", "<133% FPL")
p2 <- create_density_plot(posterior_samples, "pi_133_400", "133-400% FPL")
p3 <- create_density_plot(posterior_samples, "pi_400more", ">400% FPL")

# Arrange the plots
library(gridExtra)
grid.arrange(p1, p2, p3, ncol = 1)

```
